# NOTE: Assertions have been autogenerated by utils/update_mca_test_checks.py
# RUN: llvm-mca -mtriple=colossus -mcpu=ipu2  < %s | FileCheck %s

#  This tests MCA's ability to analyse bundled instructions
#  NOTE: Bundled instructions are not always parsed in the same order as they appear in code


#  C code from which this file was produced:

#  unsigned KnownWithBound(unsigned *arr) {
#    unsigned i = 0, z = 0;
#    unsigned j = 0;
#    do {
#      z += arr[i];
#      ++i;
#      j = j + 1.1;
#    } while (i < 0x1000);
#  
#    return z;
#  }
#


	.text
	.allow_optimizations
	.file	"basic-do-while.c"
	.section	.text.KnownWithBound,"ax",@progbits
	.globl	KnownWithBound                  # -- Begin function KnownWithBound
	.p2align	2
	.type	KnownWithBound,@function
KnownWithBound:                         # @KnownWithBound
# %bb.0:                                # %entry
	# LLVM-MCA-BEGIN bb_1
	mov	$m1, $m0
	mov	$m0, $m15
	setzi $m2, 2
# %bb.1:                                # %do.body
	{
		rpt $m2, 1
		fnop
	}
	{
		ld32step $m3, $m15, $m1+=, 1
		fnop
	}
	{
		add $m0, $m3, $m0
		fnop
	}

	# LLVM-MCA-END bb_1
# %bb.2:                                # %do.end
	br $m10
.Lfunc_end0:
	.size	KnownWithBound, .Lfunc_end0-KnownWithBound



# CHECK: 	  [0] Code Region - bb_1

# CHECK: 	  Iterations:        100
# CHECK-NEXT: Instructions:      900
# CHECK-NEXT: Total Cycles:      601
# CHECK-NEXT: Total uOps:        900

# CHECK: 	  Dispatch Width:    2
# CHECK-NEXT: uOps Per Cycle:    1.50
# CHECK-NEXT: IPC:               1.50
# CHECK-NEXT: Block RThroughput: 6.0

# CHECK: 	  Instruction Info:
# CHECK-NEXT: [1]: #uOps
# CHECK-NEXT: [2]: Latency
# CHECK-NEXT: [3]: RThroughput
# CHECK-NEXT: [4]: MayLoad
# CHECK-NEXT: [5]: MayStore
# CHECK-NEXT: [6]: HasSideEffects (U)

# CHECK: 	  [1]    [2]    [3]    [4]    [5]    [6]    Instructions:
# CHECK-NEXT:  1      1     1.00                        mov   $m1, $m0
# CHECK-NEXT:  1      1     1.00                        mov   $m0, $m15
# CHECK-NEXT:  1      1     1.00                        setzi $m2, 2
# CHECK-NEXT:  1      1     1.00                  U     rpt $m2, 1
# CHECK-NEXT:  1      1     1.00                        fnop
# CHECK-NEXT:  1      1     1.00    *                   ld32step $m3, $m15, $m1+=, 1
# CHECK-NEXT:  1      1     1.00                        fnop
# CHECK-NEXT:  1      1     1.00                        add $m0, $m3, $m0
# CHECK-NEXT:  1      1     1.00                        fnop

# CHECK: 	  Resources:
# CHECK-NEXT: [0]   - ColossusUnitAux
# CHECK-NEXT: [1]   - ColossusUnitMain


# CHECK: 	  Resource pressure per iteration:
# CHECK-NEXT: [0]    [1]
# CHECK-NEXT: 3.00   6.00


# CHECK: 	  Resource pressure by instruction:
# CHECK-NEXT: [0]    [1]    Instructions:
# CHECK-NEXT:  -     1.00   mov       $m1, $m0
# CHECK-NEXT:  -     1.00   mov       $m0, $m15
# CHECK-NEXT:  -     1.00   setzi $m2, 2
# CHECK-NEXT:  -     1.00   rpt $m2, 1
# CHECK-NEXT: 1.00    -     fnop
# CHECK-NEXT:  -     1.00   ld32step $m3, $m15, $m1+=, 1
# CHECK-NEXT: 1.00    -     fnop
# CHECK-NEXT:  -     1.00   add $m0, $m3, $m0
# CHECK-NEXT: 1.00    -     fnop
