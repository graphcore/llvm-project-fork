; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mattr=+ipu1 -march=colossus < %s | FileCheck %s --check-prefixes=BRNZDEC
; RUN: llc -mattr=+ipu1 -max-nops-in-rpt=8 -march=colossus < %s | FileCheck %s --check-prefixes=RPT

define i32 @foo(i32* %p) {
; BRNZDEC-LABEL: foo:
; BRNZDEC:       # %bb.0: # %entry
; BRNZDEC-NEXT:    mov $m1, $m15
; BRNZDEC-NEXT:    setzi $m2, 4094
; BRNZDEC-NEXT:    ld32 $m3, $m0, $m15, 1
; BRNZDEC-NEXT:    ld32 $m4, $m0, $m15, 2
; BRNZDEC-NEXT:    ld32step $m5, $m15, $m0+=, 3
; BRNZDEC-NEXT:  .LBB0_1: # %for.body
; BRNZDEC-NEXT:    # =>This Inner Loop Header: Depth=1
; BRNZDEC-NEXT:    add $m1, $m5, $m1
; BRNZDEC-NEXT:    sub $m1, $m1, $m3
; BRNZDEC-NEXT:    mov $m5, $m3
; BRNZDEC-NEXT:    mov $m3, $m4
; BRNZDEC-NEXT:    mul $m1, $m1, $m3
; BRNZDEC-NEXT:    ld32step $m4, $m15, $m0+=, 1
; BRNZDEC-NEXT:    sub $m1, $m1, $m4
; BRNZDEC-NEXT:    brnzdec $m2, .LBB0_1
; BRNZDEC-NEXT:  # %bb.2: # %for.cond.cleanup
; BRNZDEC-NEXT:    mov $m0, $m1
; BRNZDEC-NEXT:    br $m10
;
; RPT-LABEL: foo:
; RPT:       # %bb.0: # %entry
; RPT-NEXT:    mov $m1, $m15
; RPT-NEXT:    ld32 $m3, $m0, $m15, 1
; RPT-NEXT:    ld32 $m4, $m0, $m15, 2
; RPT-NEXT:    ld32step $m5, $m15, $m0+=, 3
; RPT-NEXT:  # %bb.1: # %for.body
; RPT-NEXT:    {
; RPT-NEXT:     rpt 4095, 6
; RPT-NEXT:     fnop
; RPT-NEXT:    }
; RPT-NEXT:    {
; RPT-NEXT:     add $m1, $m5, $m1
; RPT-NEXT:     fnop
; RPT-NEXT:    }
; RPT-NEXT:    {
; RPT-NEXT:     sub $m1, $m1, $m3
; RPT-NEXT:     fnop
; RPT-NEXT:    }
; RPT-NEXT:    {
; RPT-NEXT:     mov $m5, $m3
; RPT-NEXT:     fnop
; RPT-NEXT:    }
; RPT-NEXT:    {
; RPT-NEXT:     mov $m3, $m4
; RPT-NEXT:     fnop
; RPT-NEXT:    }
; RPT-NEXT:    {
; RPT-NEXT:     mul $m1, $m1, $m3
; RPT-NEXT:     fnop
; RPT-NEXT:    }
; RPT-NEXT:    {
; RPT-NEXT:     ld32step $m4, $m15, $m0+=, 1
; RPT-NEXT:     fnop
; RPT-NEXT:    }
; RPT-NEXT:    {
; RPT-NEXT:     sub $m1, $m1, $m4
; RPT-NEXT:     fnop
; RPT-NEXT:    }
; RPT-NEXT:  # %bb.2: # %for.cond.cleanup
; RPT-NEXT:    mov $m0, $m1
; RPT-NEXT:    br $m10
entry:
  %.pre = load i32, i32* %p, align 4
  %arrayidx1.phi.trans.insert = getelementptr inbounds i32, i32* %p, i32 1
  %.pre23 = load i32, i32* %arrayidx1.phi.trans.insert, align 4
  %arrayidx4.phi.trans.insert = getelementptr inbounds i32, i32* %p, i32 2
  %.pre24 = load i32, i32* %arrayidx4.phi.trans.insert, align 4
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  ret i32 %sub7

for.body:                                         ; preds = %entry, %for.body
  %0 = phi i32 [ %.pre24, %entry ], [ %3, %for.body ]
  %1 = phi i32 [ %.pre23, %entry ], [ %0, %for.body ]
  %2 = phi i32 [ %.pre, %entry ], [ %1, %for.body ]
  %i.022 = phi i32 [ 0, %entry ], [ %add, %for.body ]
  %ret.021 = phi i32 [ 0, %entry ], [ %sub7, %for.body ]
  %add = add nuw nsw i32 %i.022, 1
  %sub = add i32 %2, %ret.021
  %add2 = sub i32 %sub, %1
  %mul = mul i32 %add2, %0
  %add5 = add nuw nsw i32 %i.022, 3
  %arrayidx6 = getelementptr inbounds i32, i32* %p, i32 %add5
  %3 = load i32, i32* %arrayidx6, align 4
  %sub7 = sub i32 %mul, %3
  %exitcond.not = icmp eq i32 %add, 4095
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}
