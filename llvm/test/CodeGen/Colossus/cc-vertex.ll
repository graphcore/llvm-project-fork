; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --remove_checks
; RUN: llc < %s -march=colossus -mattr=+ipu1 | FileCheck %s --check-prefixes=CHECK,IPU1_2
; RUN: llc < %s -march=colossus -mattr=+ipu2 | FileCheck %s --check-prefixes=CHECK,IPU1_2


@len = external global i32
declare void @sink(i32 *, i32 *)
declare void @foo(i32 %a, i32 %b, i32 %c)
@x = external global i32
attributes #16 = {alignstack=16}

define colossus_vertex void @exit_void()  {
; CHECK-LABEL: exit_void:
; CHECK:       # %bb.0:
; CHECK-NEXT:    exitz $m15
  ret void
}

define colossus_vertex i32 @exit_0()  {
; CHECK-LABEL: exit_0:
; CHECK:       # %bb.0:
; CHECK-NEXT:    exitnz $m15
  ret i32 0
}

define colossus_vertex i32 @exit_1()  {
; CHECK-LABEL: exit_1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    exitz $m15
  ret i32 1
}

define colossus_vertex i32 @exit_2()  {
; CHECK-LABEL: exit_2:
; CHECK:       # %bb.0:
; CHECK-NEXT:    exitz $m15
  ret i32 2
}

define colossus_vertex i32 @exit_m1()  {
; CHECK-LABEL: exit_m1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    exitz $m15
  ret i32 -1
}

define colossus_vertex i1 @exit_pos() {
; CHECK-LABEL: exit_pos:
; CHECK:       # %bb.0:
; CHECK-NEXT:    setzi $m0, x
; CHECK-NEXT:    ld32 $m0, $m0, $m15, 0
; CHECK-NEXT:    exitpos $m0
  %px = getelementptr i32, i32* @x, i32 0
  %vx = load i32, i32* %px
  %cmp = icmp sge i32 %vx, 0
  ret i1 %cmp
}

define colossus_vertex i1 @exit_neg() {
; CHECK-LABEL: exit_neg:
; CHECK:       # %bb.0:
; CHECK-NEXT:    setzi $m0, x
; CHECK-NEXT:    ld32 $m0, $m0, $m15, 0
; CHECK-NEXT:    exitneg $m0
  %px = getelementptr i32, i32* @x, i32 0
  %vx = load i32, i32* %px
  %cmp = icmp slt i32 %vx, 0
  ret i1 %cmp
}

define colossus_vertex i1 @exit_non_zero() {
; CHECK-LABEL: exit_non_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    setzi $m0, x
; CHECK-NEXT:    ld32 $m0, $m0, $m15, 0
; CHECK-NEXT:    exitnz $m0
  %px = getelementptr i32, i32* @x, i32 0
  %vx = load i32, i32* %px
  %cmp = icmp ne i32 %vx, 0
  ret i1 %cmp
}

define colossus_vertex i1 @exit_zero() {
; CHECK-LABEL: exit_zero:
; CHECK:       # %bb.0:
; CHECK-NEXT:    setzi $m0, x
; CHECK-NEXT:    ld32 $m0, $m0, $m15, 0
; CHECK-NEXT:    exitz $m0
  %px = getelementptr i32, i32* @x, i32 0
  %vx = load i32, i32* %px
  %cmp = icmp eq i32 %vx, 0
  ret i1 %cmp
}

define colossus_vertex void @vertex_using_stack() {
; CHECK-LABEL: vertex_using_stack:
; CHECK:       # %bb.0:
; CHECK-NEXT:    add $m11, $m12, -400
; CHECK-NEXT:    exitz $m15
  %1 = alloca i32, i32 100
  ret void
}

; No stack use, but a call requires SP to be set from $WORKER_BASE.
define colossus_vertex void @vertex_with_call() {
; CHECK-LABEL: vertex_with_call:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mov $m11, $m12
; CHECK-NEXT:    setzi $m0, 42
; CHECK-NEXT:    setzi $m1, 43
; CHECK-NEXT:    setzi $m2, 44
; CHECK-NEXT:    call $m10, foo
; CHECK-NEXT:    exitz $m15
  call void @foo(i32 42, i32 43, i32 44)
  ret void
}

; Clobber a callee-save register, but this shouldn't cause a spill.
define colossus_vertex void @vertex_no_callee_saves() {
; CHECK-LABEL: vertex_no_callee_saves:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mov $m9, $m15
; CHECK-NEXT:    #APP
; CHECK-NEXT:    exitneg $m9
; CHECK-NEXT:    #NO_APP
; CHECK-NEXT:    exitz $m15
  call void asm sideeffect "exitneg $0", "{$m9}"(i32 0)
  ret void
}

define colossus_vertex i1 @vertex_with_stack_usage() {
; CHECK-LABEL: vertex_with_stack_usage:
; CHECK:       # %bb.0:
; CHECK-NEXT:    add $m11, $m12, -16
; CHECK-NEXT:    exitnz $m15
  %x = alloca i32, i32 4
  ret i1 0
}

define colossus_vertex i1 @vertex_with_stack_alignment() #16 {
; CHECK-LABEL: vertex_with_stack_alignment:
; CHECK:       # %bb.0:
; CHECK-NEXT:    add $m11, $m12, -16
; CHECK-NEXT:    andc $m11, $m11, 15
; CHECK-NEXT:    exitnz $m15
  %x = alloca i32, i32 1
  ret i1 0
}

; Uses $sp as frame size is zero
define colossus_vertex i1 @vertex_with_runtime_stack() {
; CHECK-LABEL: vertex_with_runtime_stack:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mov $m11, $m12
; CHECK-NEXT:    setzi $m0, len
; CHECK-NEXT:    ld32 $m0, $m0, $m15, 0
; CHECK-NEXT:    shl $m0, $m0, 2
; CHECK-NEXT:    add $m0, $m0, 7
; CHECK-NEXT:    andc $m0, $m0, 7
; CHECK-NEXT:    sub $m11, $m11, $m0
; CHECK-NEXT:    exitnz $m15
  %l = load i32, i32 * @len
  %x = alloca i32, i32 %l
  ret i1 0
}

define colossus_vertex i1 @vertex_with_runtime_stack_and_call() {
; CHECK-LABEL: vertex_with_runtime_stack_and_call:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mov $m11, $m12
; CHECK-NEXT:    setzi $m0, len
; CHECK-NEXT:    ld32 $m0, $m0, $m15, 0
; CHECK-NEXT:    shl $m0, $m0, 2
; CHECK-NEXT:    add $m0, $m0, 7
; CHECK-NEXT:    andc $m0, $m0, 7
; CHECK-NEXT:    sub $m0, $m11, $m0
; CHECK-NEXT:    mov $m11, $m0
; CHECK-NEXT:    mov $m1, $m0
; CHECK-NEXT:    call $m10, sink
; CHECK-NEXT:    exitnz $m15
  %l = load i32, i32 * @len
  %x = alloca i32, i32 %l
  call void @sink(i32* %x, i32* %x)
  ret i1 0
}

define colossus_vertex i1 @vertex_with_runtime_and_static_stack() {
; CHECK-LABEL: vertex_with_runtime_and_static_stack:
; CHECK:       # %bb.0:
; CHECK-NEXT:    add $m11, $m12, -8
; CHECK-NEXT:    mov $m9, $m11
; CHECK-NEXT:    setzi $m0, len
; CHECK-NEXT:    ld32 $m0, $m0, $m15, 0
; CHECK-NEXT:    shl $m0, $m0, 2
; CHECK-NEXT:    add $m0, $m0, 7
; CHECK-NEXT:    andc $m0, $m0, 7
; CHECK-NEXT:    sub $m0, $m11, $m0
; CHECK-NEXT:    mov $m11, $m0
; CHECK-NEXT:    add $m1, $m9, 4
; CHECK-NEXT:    call $m10, sink
; CHECK-NEXT:    exitnz $m15
  %l = load i32, i32 * @len
  %x = alloca i32, i32 %l
  %y = alloca i32, i32 1
  call void @sink(i32* %x, i32* %y)
  ret i1 0
}

define colossus_vertex i1 @vertex_with_runtime_and_static_stack_and_alignment() #16{
; CHECK-LABEL: vertex_with_runtime_and_static_stack_and_alignment:
; CHECK:       # %bb.0:
; CHECK-NEXT:    add $m11, $m12, -16
; CHECK-NEXT:    andc $m11, $m11, 15
; CHECK-NEXT:    mov $m9, $m11
; CHECK-NEXT:    setzi $m0, len
; CHECK-NEXT:    ld32 $m0, $m0, $m15, 0
; CHECK-NEXT:    shl $m0, $m0, 2
; CHECK-NEXT:    add $m0, $m0, 7
; CHECK-NEXT:    andc $m0, $m0, 7
; CHECK-NEXT:    sub $m0, $m11, $m0
; CHECK-NEXT:    mov $m11, $m0
; CHECK-NEXT:    add $m1, $m9, 12
; CHECK-NEXT:    call $m10, sink
; CHECK-NEXT:    exitnz $m15
  %l = load i32, i32 * @len
  %x = alloca i32, i32 %l
  %y = alloca i32, i32 1
  call void @sink(i32* %x, i32* %y)
  ret i1 0
}

; Check the dynamic stack alloc uses a writable register (not $m12)
define colossus_vertex i1 @vertex_with_runtime_stack_no_call() {
; CHECK-LABEL: vertex_with_runtime_stack_no_call:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mov $m11, $m12
; CHECK-NEXT:    setzi $m0, len
; CHECK-NEXT:    ld32 $m0, $m0, $m15, 0
; CHECK-NEXT:    shl $m0, $m0, 3
; CHECK-NEXT:    sub $m11, $m11, $m0
; CHECK-NEXT:    exitnz $m15
  %l = load i32, i32 * @len
  %l2 = mul i32 %l, 2
  %x = alloca i32, i32 %l2
  ret i1 0
}

; See T5916 for discussion of removing the mov $m9
define colossus_vertex i1 @vertex_with_runtime_and_static_stack_no_call() {
; CHECK-LABEL: vertex_with_runtime_and_static_stack_no_call:
; CHECK:       # %bb.0:
; CHECK-NEXT:    add $m11, $m12, -8
; CHECK-NEXT:    mov $m9, $m11
; CHECK-NEXT:    setzi $m0, len
; CHECK-NEXT:    ld32 $m0, $m0, $m15, 0
; CHECK-NEXT:    shl $m0, $m0, 3
; CHECK-NEXT:    sub $m11, $m11, $m0
; CHECK-NEXT:    exitnz $m15
  %l = load i32, i32 * @len
  %l2 = mul i32 %l, 2
  %x = alloca i32, i32 %l2
  %y = alloca i32, i32 1
  ret i1 0
}

@data = external global float*, align 4
@res = external global float, align 4
define colossus_vertex i32 @access_spill_slot() {
; IPU1_2-LABEL: access_spill_slot:
; IPU1_2:       # %bb.0: # %entry
; IPU1_2-NEXT:    add $m11, $m12, -8
; IPU1_2-NEXT:    setzi $m0, len
; IPU1_2-NEXT:    #APP
; IPU1_2-NEXT:    # Write fp regs
; IPU1_2-NEXT:    #NO_APP
; IPU1_2-NEXT:    ld32 $m2, $m0, $m15, 0
; IPU1_2-NEXT:    cmpslt $m0, $m2, 1
; IPU1_2-NEXT:    st64 $a0:1, $m11, $m15, 0 # 8-byte Folded Spill
; IPU1_2-NEXT:    brnz $m0, .LBB20_1
; IPU1_2-NEXT:  # %bb.2: # %for.body.preheader
; IPU1_2-NEXT:    {
; IPU1_2-NEXT:     mov $m0, $m15
; IPU1_2-NEXT:     or $a0, $a15, 1065353216
; IPU1_2-NEXT:    }
; IPU1_2-NEXT:    setzi $m1, data
; IPU1_2-NEXT:    setzi $m3, 1
; IPU1_2-NEXT:    ld32 $m4, $m1, $m15, 0
; IPU1_2-NEXT:    cmpslt $m3, $m3, $m2
; IPU1_2-NEXT:    ld32step $a1, $m4, $m0+=, 1
; IPU1_2-NEXT:    add $m2, $m2, -1
; IPU1_2-NEXT:    brz $m3, .LBB20_5
; IPU1_2-NEXT:  # %bb.3: # %for.body
; IPU1_2-NEXT:    add $m2, $m2, -1
; IPU1_2-NEXT:  .LBB20_4: # %for.body
; IPU1_2-NEXT:    # =>This Inner Loop Header: Depth=1
; IPU1_2-NEXT:    {
; IPU1_2-NEXT:     ld32 $m3, $m1, $m15, 0
; IPU1_2-NEXT:     f32add $a0, $a0, $a1
; IPU1_2-NEXT:    }
; IPU1_2-NEXT:    ld32step $a1, $m3, $m0+=, 1
; IPU1_2-NEXT:    brnzdec $m2, .LBB20_4
; IPU1_2-NEXT:  .LBB20_5:
; IPU1_2-NEXT:    {
; IPU1_2-NEXT:     bri .LBB20_6
; IPU1_2-NEXT:     f32add $a0, $a0, $a1
; IPU1_2-NEXT:    }
; IPU1_2-NEXT:  .LBB20_1:
; IPU1_2-NEXT:    or $a0, $a15, 1065353216
; IPU1_2-NEXT:  .LBB20_6: # %for.cond.cleanup
; IPU1_2-NEXT:    setzi $m0, res
; IPU1_2-NEXT:    st32 $a0, $m0, $m15, 0
; IPU1_2-NEXT:    ld64 $a0:1, $m11, $m15, 0 # 8-byte Folded Reload
; IPU1_2-NEXT:    #APP
; IPU1_2-NEXT:    # Read fp regs
; IPU1_2-NEXT:    #NO_APP
; IPU1_2-NEXT:    exitnz $m15
;
entry:
  ; Write to all fp registers
  %0 = tail call { <2 x float>, <2 x float>, <2 x float>, <2 x float> } asm "# Write fp regs", "=r,=r,=r,=r"()
  %asmr = extractvalue { <2 x float>, <2 x float>, <2 x float>, <2 x float> } %0, 0
  %asmr1 = extractvalue { <2 x float>, <2 x float>, <2 x float>, <2 x float> } %0, 1
  %asmr2 = extractvalue { <2 x float>, <2 x float>, <2 x float>, <2 x float> } %0, 2
  %asmr3 = extractvalue { <2 x float>, <2 x float>, <2 x float>, <2 x float> } %0, 3
  %1 = load i32, i32* @len, align 4
  %cmp13 = icmp sgt i32 %1, 0
  br i1 %cmp13, label %for.body, label %for.cond.cleanup

for.body:
  ; Simple loop over global variables that needs a fp register to force the spill
  %i = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %x = phi float [ 1.000000e+00, %entry ], [ %add, %for.body ]
  %2 = load float*, float** @data, align 4
  %arrayidx = getelementptr inbounds float, float* %2, i32 %i
  %3 = load float, float* %arrayidx, align 4
  %add = fadd float %x, %3
  %inc = add nuw nsw i32 %i, 1
  %cmp = icmp slt i32 %inc, %1
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:
  ; Read all fp registers
  %x.0 = phi float [ 1.000000e+00, %entry ], [ %add, %for.body ]
  store float %x.0, float* @res, align 4
  tail call void asm sideeffect "# Read fp regs", "r,r,r,r"(<2 x float> %asmr, <2 x float> %asmr1, <2 x float> %asmr2, <2 x float> %asmr3)
  ret i32 0
}
