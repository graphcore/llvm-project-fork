; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --remove_checks
; RUN: llc < %s -march=colossus -mattr=+ipu1 | FileCheck %s -check-prefixes=IPU1_2,IPU1
; RUN: llc < %s -march=colossus -mattr=+ipu2 | FileCheck %s -check-prefixes=IPU1_2,IPU2

@a = global [65536 x i32] zeroinitializer, align 4
@b = global [65536 x i32] zeroinitializer, align 4

define i32 @main() nounwind {
; IPU1_2-LABEL: main:
; IPU1_2:       # %bb.0: # %entry
; IPU1_2-NEXT:    setzi $m0, 65535
; IPU1_2-NEXT:    setzi $m1, b
; IPU1_2-NEXT:    setzi $m2, a
; IPU1_2-NEXT:    add $m3, $m15, -32768
; IPU1_2-NEXT:  .LBB0_1: # %for.body
; IPU1_2-NEXT:    # =>This Inner Loop Header: Depth=1
; IPU1_2-NEXT:    add $m4, $m3, 32768
; IPU1_2-NEXT:    st32step $m3, $m15, $m2+=, 1
; IPU1_2-NEXT:    st32step $m4, $m15, $m1+=, 1
; IPU1_2-NEXT:    add $m3, $m3, 1
; IPU1_2-NEXT:    brnzdec $m0, .LBB0_1
; IPU1_2-NEXT:  # %bb.2: # %for.end
; IPU1_2-NEXT:    mov $m0, $m15
; IPU1_2-NEXT:    br $m10
;
entry:
  br label %for.body

for.body:
  %i.08 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %sub = add nsw i32 %i.08, -32768
  %arrayidx = getelementptr inbounds [65536 x i32], [65536 x i32]* @a, i32 0, i32 %i.08
  store i32 %sub, i32* %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds [65536 x i32], [65536 x i32]* @b, i32 0, i32 %i.08
  store i32 %i.08, i32* %arrayidx1, align 4
  %inc = add nuw nsw i32 %i.08, 1
  %exitcond = icmp eq i32 %inc, 65536
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  ret i32 0
}

define i32 @main_2() nounwind {
; IPU1-LABEL: main_2:
; IPU1:       # %bb.0: # %entry
; IPU1-NEXT:    mov $m0, $m15
; IPU1-NEXT:    setzi $m1, 65534
; IPU1-NEXT:    setzi $m2, b
; IPU1-NEXT:    setzi $m3, a
; IPU1-NEXT:  .LBB1_1: # %for.body
; IPU1-NEXT:    # =>This Inner Loop Header: Depth=1
; IPU1-NEXT:    add $m4, $m0, 65535
; IPU1-NEXT:    st32step $m4, $m15, $m3+=, -1
; IPU1-NEXT:    st32step $m0, $m15, $m2+=, -1
; IPU1-NEXT:    add $m0, $m0, -1
; IPU1-NEXT:    brnzdec $m1, .LBB1_1
; IPU1-NEXT:  # %bb.2: # %for.end
; IPU1-NEXT:    mov $m0, $m15
; IPU1-NEXT:    br $m10
;
; IPU2-LABEL: main_2:
; IPU2:       # %bb.0: # %entry
; IPU2-NEXT:    mov $m0, $m15
; IPU2-NEXT:    setzi $m1, 65535
; IPU2-NEXT:    setzi $m2, b
; IPU2-NEXT:    setzi $m3, a
; IPU2-NEXT:  # %bb.1: # %for.body
; IPU2-NEXT:    {
; IPU2-NEXT:     rpt $m1, 3
; IPU2-NEXT:     fnop
; IPU2-NEXT:    }
; IPU2-NEXT:    {
; IPU2-NEXT:     add $m4, $m0, 65535
; IPU2-NEXT:     fnop
; IPU2-NEXT:    }
; IPU2-NEXT:    {
; IPU2-NEXT:     st32step $m4, $m15, $m3+=, -1
; IPU2-NEXT:     fnop
; IPU2-NEXT:    }
; IPU2-NEXT:    {
; IPU2-NEXT:     st32step $m0, $m15, $m2+=, -1
; IPU2-NEXT:     fnop
; IPU2-NEXT:    }
; IPU2-NEXT:    {
; IPU2-NEXT:     add $m0, $m0, -1
; IPU2-NEXT:     fnop
; IPU2-NEXT:    }
; IPU2-NEXT:  # %bb.2: # %for.end
; IPU2-NEXT:    mov $m0, $m15
; IPU2-NEXT:    br $m10
;
entry:
  br label %for.body

for.body:
  %i.08 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %sub = add  i32 %i.08, 65535
  %arrayidx = getelementptr inbounds [65536 x i32], [65536 x i32]* @a, i32 0, i32 %i.08
  store i32 %sub, i32* %arrayidx, align 4
  %arrayidx1 = getelementptr inbounds [65536 x i32], [65536 x i32]* @b, i32 0, i32 %i.08
  store i32 %i.08, i32* %arrayidx1, align 4
  %inc = add  i32 %i.08, -1
  %exitcond = icmp eq i32 %inc, -65535
  br i1 %exitcond, label %for.end, label %for.body

for.end:
  ret i32 0
}
